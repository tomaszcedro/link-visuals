<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Link Visuals Studio — Tetris 32×20</title>

<style>
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:grid;
    place-items:center;
    background:#0b0f1a;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    color:#eaeefc;
  }
  .stage{
    width:min(98vw, 1800px);
    aspect-ratio:16/9;
    display:flex;
    flex-direction:column;
    padding:22px;
    border-radius:16px;
    background:#0f1424;
    box-shadow:0 20px 60px rgba(0,0,0,.45);
    position:relative;
    overflow:hidden;
  }
  .header{ text-align:center; padding:8px 0 16px; }
  .header h1{
    margin:0;
    font-size:clamp(22px, 2.2vw, 32px);
    letter-spacing:6px;
    font-weight:650;
    text-transform:uppercase;
  }
  .boardWrap{
    flex:1;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  canvas{
    border-radius:14px;
    image-rendering:auto;
    background-image:url("tlo.jpeg");
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    display:block;
  }
  .hud{
    position:absolute;
    right:22px;
    top:18px;
    font-weight:900;
    font-size:22px;
    letter-spacing:1px;
    user-select:none;
    text-shadow:0 2px 10px rgba(0,0,0,.6);
  }
</style>
</head>

<body>
<div class="stage">
  <div class="header"><h1>LINK VISUALS</h1></div>
  <div class="hud" id="score">0</div>
  <div class="boardWrap">
    <canvas id="board"></canvas>
  </div>
</div>

<script>
(() => {
  const COLS = 32, ROWS = 20;
  let CELL = 14;

  const COLORS = {
    I:"#3CF2FF", O:"#FFD93D", T:"#B56CFF",
    S:"#57FF7A", Z:"#FF4D6D",
    J:"#4D7CFF", L:"#FF9B3D"
  };

  const SHAPES = {
    I:[[[0,1],[1,1],[2,1],[3,1]],[[2,0],[2,1],[2,2],[2,3]]],
    O:[[[1,0],[2,0],[1,1],[2,1]]],
    T:[
      [[1,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[2,1],[1,2]],
      [[0,1],[1,1],[2,1],[1,2]],
      [[1,0],[0,1],[1,1],[1,2]]
    ],
    S:[[[1,0],[2,0],[0,1],[1,1]],[[1,0],[1,1],[2,1],[2,2]]],
    Z:[[[0,0],[1,0],[1,1],[2,1]],[[2,0],[1,1],[2,1],[1,2]]],
    J:[
      [[0,0],[0,1],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[1,2]],
      [[0,1],[1,1],[2,1],[2,2]],
      [[1,0],[1,1],[0,2],[1,2]]
    ],
    L:[
      [[2,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[1,2],[2,2]],
      [[0,1],[1,1],[2,1],[0,2]],
      [[0,0],[1,0],[1,1],[1,2]]
    ]
  };
  const PIECES = Object.keys(SHAPES);

  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d", { alpha:true });
  const scoreEl = document.getElementById("score");

  const emptyRow = () => Array(COLS).fill(null);

  let grid, current, score = 0;
  let aiEnabled = false;
  let plan = null;

  let dropTimer = 0, lastTime = null;
  const baseDrop = 260, softDrop = 55;
  let downHeld = false;

  // smooth falling fraction (0..1)
  let fallProgress = 0;

  function resize(){
    const wrap = canvas.parentElement;

    CELL = Math.max(12, Math.floor(Math.min(
      wrap.clientWidth / COLS,
      wrap.clientHeight / ROWS
    )));
    const cssW = COLS * CELL;
    const cssH = ROWS * CELL;

    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";

    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  function spawn(){
    const type = PIECES[(Math.random()*PIECES.length)|0];
    return { type, rot:0, x:Math.floor(COLS/2)-2, y:0 };
  }

  function collides(p,dx=0,dy=0,drot=0){
    const r = (p.rot+drot+SHAPES[p.type].length)%SHAPES[p.type].length;
    for(const [cx,cy] of SHAPES[p.type][r]){
      const x=p.x+cx+dx, y=p.y+cy+dy;
      if(x<0||x>=COLS||y<0||y>=ROWS||grid[y][x]) return true;
    }
    return false;
  }

  function clearLines(){
    let lines = 0;
    for(let y=ROWS-1;y>=0;y--){
      if(grid[y].every(Boolean)){
        grid.splice(y,1);
        grid.unshift(emptyRow());
        lines++; y++;
      }
    }
    if(lines){
      score += lines * 1000;
      scoreEl.textContent = score;
    }
  }

  function lock(){
    for(const [cx,cy] of SHAPES[current.type][current.rot]){
      const x=current.x+cx, y=current.y+cy;
      if(y>=0&&y<ROWS&&x>=0&&x<COLS) grid[y][x]=current.type;
    }
    clearLines();
    current = spawn();
    plan = null;
    fallProgress = 0;
    if(collides(current)) reset();
    else if(aiEnabled) plan = bestPlan();
  }

  function reset(){
    grid = Array.from({length:ROWS}, emptyRow);
    current = spawn();
    score = 0;
    scoreEl.textContent = "0";
    dropTimer = 0;
    lastTime = null;
    downHeld = false;
    plan = null;
    fallProgress = 0;
    if(aiEnabled) plan = bestPlan();
  }

  function drawBlockCell(x, y, color){
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = color;
    ctx.fillRect(x*CELL+1, y*CELL+1, CELL-2, CELL-2);
    ctx.globalAlpha = 1;
  }

  function draw(){
    const w = COLS * CELL;
    const h = ROWS * CELL;

    ctx.clearRect(0,0,w,h);

    // darken background 70%
    ctx.fillStyle="rgba(0,0,0,0.70)";
    ctx.fillRect(0,0,w,h);

    // locked blocks
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(grid[y][x]) drawBlockCell(x, y, COLORS[grid[y][x]]);
      }
    }

    // current block (smooth)
    for(const [cx,cy] of SHAPES[current.type][current.rot]){
      const x = current.x + cx;
      const yFloat = current.y + cy + fallProgress;
      if(yFloat >= 0){
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = COLORS[current.type];
        ctx.fillRect(x*CELL+1, yFloat*CELL+1, CELL-2, CELL-2);
        ctx.globalAlpha = 1;
      }
    }
  }

  /* ===== AI ===== */
  function cloneGrid(g){ return g.map(r=>r.slice()); }
  function place(g,p){
    const ng=cloneGrid(g);
    for(const [cx,cy] of SHAPES[p.type][p.rot]){
      const x=p.x+cx,y=p.y+cy;
      if(y>=0&&y<ROWS&&x>=0&&x<COLS) ng[y][x]=p.type;
    }
    let cl=0;
    for(let y=ROWS-1;y>=0;y--){
      if(ng[y].every(Boolean)){
        ng.splice(y,1); ng.unshift(emptyRow()); cl++; y++;
      }
    }
    return {ng,cl};
  }
  function heights(g){
    return Array.from({length:COLS},(_,x)=>{
      let y=0; while(y<ROWS&&!g[y][x])y++; return ROWS-y;
    });
  }
  function holes(g){
    let h=0;
    for(let x=0;x<COLS;x++){
      let s=false;
      for(let y=0;y<ROWS;y++){
        if(g[y][x]) s=true;
        else if(s) h++;
      }
    }
    return h;
  }
  function bump(h){
    return h.slice(1).reduce((a,v,i)=>a+Math.abs(v-h[i]),0);
  }
  function sum(h){ return h.reduce((a,b)=>a+b,0); }

  function bestPlan(){
    let best=null;
    for(let r=0;r<SHAPES[current.type].length;r++){
      const cells=SHAPES[current.type][r];
      const minX=Math.min(...cells.map(c=>c[0]));
      const maxX=Math.max(...cells.map(c=>c[0]));
      for(let x=-minX;x<COLS-maxX;x++){
        const p={type:current.type,rot:r,x,y:0};
        if(collides(p)) continue;
        while(!collides(p,0,1)) p.y++;
        const {ng,cl}=place(grid,p);
        const h=heights(ng);
        const v=cl*1400 - holes(ng)*55 - sum(h)*4 - bump(h)*10;
        if(!best||v>best.v) best={targetX:x,targetRot:r,v};
      }
    }
    return best;
  }

  function rotateKick(){
    const nr=(current.rot+1)%SHAPES[current.type].length;
    if(!collides(current,0,0,1)){current.rot=nr;return;}
    for(const k of[-1,1,-2,2]){
      if(!collides(current,k,0,1)){
        current.x+=k; current.rot=nr; return;
      }
    }
  }

  function aiSteer(){
    if(!plan) plan=bestPlan();
    if(!plan) return;
    if(current.rot!==plan.targetRot){ rotateKick(); return; }
    if(current.x<plan.targetX&&!collides(current,1,0)) current.x++;
    else if(current.x>plan.targetX&&!collides(current,-1,0)) current.x--;
    // bez “popychania” fallProgress — to eliminuje artefakty
  }

  /* ===== CONTROLS ===== */
  window.addEventListener("keydown",e=>{
    if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","i","r"].includes(e.key)) e.preventDefault();

    if(e.key==="i"||e.key==="I"){
      aiEnabled=!aiEnabled;
      downHeld=false;
      plan=null;
      if(aiEnabled) plan=bestPlan();
      return;
    }
    if(e.key==="r"||e.key==="R"){
      reset(); return;
    }
    if(aiEnabled) return;

    if(e.key==="ArrowLeft"&&!collides(current,-1,0)) current.x--;
    else if(e.key==="ArrowRight"&&!collides(current,1,0)) current.x++;
    else if(e.key==="ArrowUp") rotateKick();
    else if(e.key==="ArrowDown") downHeld=true;
  },{passive:false});

  window.addEventListener("keyup",e=>{
    if(e.key==="ArrowDown") downHeld=false;
  });

  function step(t){
    if(lastTime===null) lastTime=t;
    const dt=t-lastTime; lastTime=t;

    if(aiEnabled) aiSteer();

    const interval = (!aiEnabled && downHeld) ? softDrop : baseDrop;

    // KLUCZOWA POPRAWKA:
    // jeśli klocek już "stoi" (kolizja pod spodem), NIE dodajemy fallProgress
    // i blokujemy go tylko w rytmie ticków, bez przelatywania wizualnie.
    if (collides(current, 0, 1)) {
      fallProgress = 0;
      dropTimer += dt;
      if (dropTimer >= interval) {
        dropTimer = 0;
        lock();
      }
    } else {
      dropTimer += dt;
      fallProgress += dt / interval;

      while (fallProgress >= 1) {
        fallProgress -= 1;
        if (!collides(current, 0, 1)) {
          current.y++;
        } else {
          fallProgress = 0;
          dropTimer = 0;
          lock();
          break;
        }
      }
    }

    draw();
    requestAnimationFrame(step);
  }

  reset();
  resize();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
