<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Link Visuals — Tetris 32×20</title>

<style>
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    display:grid;
    place-items:center;
    background:#0b0f1a;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    color:#eaeefc;
    overscroll-behavior:none;
  }

  .stage{
    width:min(98vw, 1800px);
    height:min(98vh, 980px);
    aspect-ratio:16/9;
    display:flex;
    flex-direction:column;
    padding:16px;
    border-radius:16px;
    background:#0f1424;
    box-shadow:0 20px 60px rgba(0,0,0,.45);
    position:relative;
    overflow:hidden;
  }

  /* Na wąskich ekranach pozwól stage zająć prawie całe okno */
  @media (max-width: 820px) {
    .stage{
      width:100vw;
      height:100vh;
      max-width:100vw;
      max-height:100vh;
      border-radius:0;
      padding:12px;
      aspect-ratio:auto; /* mobile: dopasuj do ekranu */
    }
  }

  .header{ text-align:center; padding:6px 0 10px; }
  .header h1{
    margin:0;
    font-size:clamp(18px, 3.2vw, 30px);
    letter-spacing:6px;
    font-weight:650;
    text-transform:uppercase;
    line-height:1.1;
  }

  .boardWrap{
    flex:1;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    min-height:0;
  }

  canvas{
    border-radius:14px;
    image-rendering:auto;
    background-image:url("tlo.jpeg");
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    display:block;
    touch-action:none; /* ważne dla mobilnych */
  }

  .hud{
    position:absolute;
    right:14px;
    top:12px;
    font-weight:900;
    font-size:20px;
    letter-spacing:1px;
    user-select:none;
    text-shadow:0 2px 10px rgba(0,0,0,.6);
    z-index:5;
  }

  /* Mobile controls (pokazywane tylko gdy JS doda .is-mobile) */
  .controls{
    display:none;
    position:absolute;
    left:0; right:0;
    bottom:0;
    padding:12px;
    gap:10px;
    z-index:10;
    pointer-events:auto;
  }
  .is-mobile .controls{ display:grid; }

  .controls .row{
    display:flex;
    gap:10px;
    justify-content:center;
    align-items:center;
  }

  .btn{
    appearance:none;
    border:none;
    border-radius:14px;
    padding:14px 16px;
    min-width:64px;
    background:rgba(255,255,255,0.10);
    color:#fff;
    font-weight:800;
    font-size:18px;
    letter-spacing:.5px;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    border:1px solid rgba(255,255,255,0.14);
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
  }
  .btn:active{ transform:scale(0.98); }

  .btn.small{
    min-width:64px;
    padding:12px 14px;
    font-size:16px;
    opacity:.95;
  }
  .btn.wide{
    min-width:110px;
  }

  .btn.on{
    background:rgba(80,255,180,0.18);
    border-color:rgba(80,255,180,0.30);
  }
</style>
</head>

<body>
<div class="stage" id="stage">
  <div class="header"><h1>LINK VISUALS</h1></div>
  <div class="hud" id="score">0</div>

  <div class="boardWrap">
    <canvas id="board"></canvas>

    <!-- Mobile-only controls -->
    <div class="controls" id="controls">
      <div class="row">
        <button class="btn small wide" id="btnAI" title="AI">AI</button>
        <button class="btn small wide" id="btnR" title="Reset">R</button>
      </div>
      <div class="row">
        <button class="btn" id="btnLeft">◀</button>
        <button class="btn" id="btnRotate">⟳</button>
        <button class="btn" id="btnRight">▶</button>
      </div>
      <div class="row">
        <button class="btn wide" id="btnDown">▼</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const COLS = 32, ROWS = 20;
  let CELL = 14;

  const COLORS = {
    I:"#3CF2FF", O:"#FFD93D", T:"#B56CFF",
    S:"#57FF7A", Z:"#FF4D6D",
    J:"#4D7CFF", L:"#FF9B3D"
  };

  const SHAPES = {
    I:[[[0,1],[1,1],[2,1],[3,1]],[[2,0],[2,1],[2,2],[2,3]]],
    O:[[[1,0],[2,0],[1,1],[2,1]]],
    T:[
      [[1,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[2,1],[1,2]],
      [[0,1],[1,1],[2,1],[1,2]],
      [[1,0],[0,1],[1,1],[1,2]]
    ],
    S:[[[1,0],[2,0],[0,1],[1,1]],[[1,0],[1,1],[2,1],[2,2]]],
    Z:[[[0,0],[1,0],[1,1],[2,1]],[[2,0],[1,1],[2,1],[1,2]]],
    J:[
      [[0,0],[0,1],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[1,2]],
      [[0,1],[1,1],[2,1],[2,2]],
      [[1,0],[1,1],[0,2],[1,2]]
    ],
    L:[
      [[2,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[1,2],[2,2]],
      [[0,1],[1,1],[2,1],[0,2]],
      [[0,0],[1,0],[1,1],[1,2]]
    ]
  };
  const PIECES = Object.keys(SHAPES);

  const stage = document.getElementById("stage");
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d", { alpha:true });
  const scoreEl = document.getElementById("score");

  const emptyRow = () => Array(COLS).fill(null);

  let grid, current, score = 0;
  let aiEnabled = false;
  let plan = null;

  let dropTimer = 0, lastTime = null;
  const baseDrop = 260, softDrop = 55;
  let downHeld = false;
  let fallProgress = 0;

  // --- mobile detect & UI ---
  const isMobile =
    window.matchMedia?.("(pointer: coarse)").matches ||
    ("ontouchstart" in window) ||
    navigator.maxTouchPoints > 0;

  if (isMobile) stage.classList.add("is-mobile");

  // --- sizing / hiDPI ---
  function resize(){
    const wrap = canvas.parentElement;

    // Zostaw miejsce na przyciski na mobile (żeby nie zasłaniały planszy)
    const controls = document.getElementById("controls");
    const controlsH = (isMobile && controls) ? controls.getBoundingClientRect().height : 0;

    const availableW = wrap.clientWidth;
    const availableH = wrap.clientHeight - controlsH;

    CELL = Math.max(12, Math.floor(Math.min(
      availableW / COLS,
      availableH / ROWS
    )));

    const cssW = COLS * CELL;
    const cssH = ROWS * CELL;

    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";

    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  function spawn(){
    const type = PIECES[(Math.random()*PIECES.length)|0];
    return { type, rot:0, x:Math.floor(COLS/2)-2, y:0 };
  }

  function collides(p,dx=0,dy=0,drot=0){
    const r = (p.rot+drot+SHAPES[p.type].length)%SHAPES[p.type].length;
    for(const [cx,cy] of SHAPES[p.type][r]){
      const x=p.x+cx+dx, y=p.y+cy+dy;
      if(x<0||x>=COLS||y<0||y>=ROWS||grid[y][x]) return true;
    }
    return false;
  }

  function clearLines(){
    let lines = 0;
    for(let y=ROWS-1;y>=0;y--){
      if(grid[y].every(Boolean)){
        grid.splice(y,1);
        grid.unshift(emptyRow());
        lines++; y++;
      }
    }
    if(lines){
      score += lines * 1000;
      scoreEl.textContent = score;
    }
  }

  function lock(){
    for(const [cx,cy] of SHAPES[current.type][current.rot]){
      const x=current.x+cx, y=current.y+cy;
      if(y>=0&&y<ROWS&&x>=0&&x<COLS) grid[y][x]=current.type;
    }
    clearLines();
    current = spawn();
    plan = null;
    fallProgress = 0;
    if(collides(current)) reset();
    else if(aiEnabled) plan = bestPlan();
  }

  function reset(){
    grid = Array.from({length:ROWS}, emptyRow);
    current = spawn();
    score = 0;
    scoreEl.textContent = "0";
    dropTimer = 0;
    lastTime = null;
    downHeld = false;
    plan = null;
    fallProgress = 0;
    if(aiEnabled) plan = bestPlan();
    syncAIBtn();
  }

  function draw(){
    const w = COLS * CELL;
    const h = ROWS * CELL;

    ctx.clearRect(0,0,w,h);

    // darken background 70%
    ctx.fillStyle="rgba(0,0,0,0.70)";
    ctx.fillRect(0,0,w,h);

    // locked blocks
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(grid[y][x]){
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = COLORS[grid[y][x]];
          ctx.fillRect(x*CELL+1, y*CELL+1, CELL-2, CELL-2);
          ctx.globalAlpha = 1;
        }
      }
    }

    // current block (smooth)
    for(const [cx,cy] of SHAPES[current.type][current.rot]){
      const x = current.x + cx;
      const yFloat = current.y + cy + fallProgress;
      if(yFloat >= 0){
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = COLORS[current.type];
        ctx.fillRect(x*CELL+1, yFloat*CELL+1, CELL-2, CELL-2);
        ctx.globalAlpha = 1;
      }
    }
  }

  // --- AI ---
  function cloneGrid(g){ return g.map(r=>r.slice()); }
  function place(g,p){
    const ng=cloneGrid(g);
    for(const [cx,cy] of SHAPES[p.type][p.rot]){
      const x=p.x+cx,y=p.y+cy;
      if(y>=0&&y<ROWS&&x>=0&&x<COLS) ng[y][x]=p.type;
    }
    let cl=0;
    for(let y=ROWS-1;y>=0;y--){
      if(ng[y].every(Boolean)){
        ng.splice(y,1); ng.unshift(emptyRow()); cl++; y++;
      }
    }
    return {ng,cl};
  }
  function heights(g){
    return Array.from({length:COLS},(_,x)=>{
      let y=0; while(y<ROWS&&!g[y][x])y++; return ROWS-y;
    });
  }
  function holes(g){
    let h=0;
    for(let x=0;x<COLS;x++){
      let s=false;
      for(let y=0;y<ROWS;y++){
        if(g[y][x]) s=true;
        else if(s) h++;
      }
    }
    return h;
  }
  function bump(h){
    return h.slice(1).reduce((a,v,i)=>a+Math.abs(v-h[i]),0);
  }
  function sum(h){ return h.reduce((a,b)=>a+b,0); }

  function bestPlan(){
    let best=null;
    for(let r=0;r<SHAPES[current.type].length;r++){
      const cells=SHAPES[current.type][r];
      const minX=Math.min(...cells.map(c=>c[0]));
      const maxX=Math.max(...cells.map(c=>c[0]));
      for(let x=-minX;x<COLS-maxX;x++){
        const p={type:current.type,rot:r,x,y:0};
        if(collides(p)) continue;
        while(!collides(p,0,1)) p.y++;
        const {ng}=place(grid,p);
        const h=heights(ng);
        const v=- holes(ng)*55 - sum(h)*4 - bump(h)*10;
        if(!best||v>best.v) best={targetX:x,targetRot:r,v};
      }
    }
    return best;
  }

  function rotateKick(){
    const nr=(current.rot+1)%SHAPES[current.type].length;
    if(!collides(current,0,0,1)){current.rot=nr;return;}
    for(const k of[-1,1,-2,2]){
      if(!collides(current,k,0,1)){
        current.x+=k; current.rot=nr; return;
      }
    }
  }

  function aiSteer(){
    if(!plan) plan=bestPlan();
    if(!plan) return;
    if(current.rot!==plan.targetRot){ rotateKick(); return; }
    if(current.x<plan.targetX&&!collides(current,1,0)) current.x++;
    else if(current.x>plan.targetX&&!collides(current,-1,0)) current.x--;
  }

  function toggleAI(){
    aiEnabled = !aiEnabled;
    plan = null;
    downHeld = false;
    syncAIBtn();
  }

  function syncAIBtn(){
    const btnAI = document.getElementById("btnAI");
    if(!btnAI) return;
    btnAI.classList.toggle("on", aiEnabled);
  }

  // --- Keyboard controls (desktop + też działa na mobile z klawiaturą) ---
  window.addEventListener("keydown",e=>{
    if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","i","r"].includes(e.key)) e.preventDefault();

    if(e.key==="i"||e.key==="I"){ toggleAI(); return; }
    if(e.key==="r"||e.key==="R"){ reset(); return; }
    if(aiEnabled) return;

    if(e.key==="ArrowLeft"&&!collides(current,-1,0)) current.x--;
    else if(e.key==="ArrowRight"&&!collides(current,1,0)) current.x++;
    else if(e.key==="ArrowUp") rotateKick();
    else if(e.key==="ArrowDown") downHeld=true;
  },{passive:false});

  window.addEventListener("keyup",e=>{
    if(e.key==="ArrowDown") downHeld=false;
  });

  // --- Mobile buttons ---
  function holdButton(el, onTick, interval=55){
    let timer = null;
    const start = (ev) => {
      ev.preventDefault();
      if(timer) return;
      onTick(); // szybka reakcja
      timer = setInterval(onTick, interval);
    };
    const stop = (ev) => {
      if(ev) ev.preventDefault();
      if(timer){ clearInterval(timer); timer=null; }
    };

    el.addEventListener("pointerdown", start, {passive:false});
    el.addEventListener("pointerup", stop, {passive:false});
    el.addEventListener("pointercancel", stop, {passive:false});
    el.addEventListener("pointerleave", stop, {passive:false});
  }

  function bindMobileControls(){
    if(!isMobile) return;

    const btnLeft = document.getElementById("btnLeft");
    const btnRight = document.getElementById("btnRight");
    const btnRotate = document.getElementById("btnRotate");
    const btnDown = document.getElementById("btnDown");
    const btnAI = document.getElementById("btnAI");
    const btnR = document.getElementById("btnR");

    // zapobiegaj scrollowi/zoomowi podczas gry
    document.addEventListener("touchmove", (e) => e.preventDefault(), {passive:false});

    holdButton(btnLeft, () => {
      if(aiEnabled) return;
      if(!collides(current,-1,0)) current.x--;
    }, 70);

    holdButton(btnRight, () => {
      if(aiEnabled) return;
      if(!collides(current,1,0)) current.x++;
    }, 70);

    btnRotate.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      if(aiEnabled) return;
      rotateKick();
    }, {passive:false});

    // Soft drop while holding
    btnDown.addEventListener("pointerdown", (e) => { e.preventDefault(); if(aiEnabled) return; downHeld = true; }, {passive:false});
    btnDown.addEventListener("pointerup",   (e) => { e.preventDefault(); downHeld = false; }, {passive:false});
    btnDown.addEventListener("pointercancel",(e)=> { e.preventDefault(); downHeld = false; }, {passive:false});
    btnDown.addEventListener("pointerleave",(e)=> { e.preventDefault(); downHeld = false; }, {passive:false});

    btnAI.addEventListener("pointerdown", (e) => { e.preventDefault(); toggleAI(); }, {passive:false});
    btnR.addEventListener("pointerdown", (e) => { e.preventDefault(); reset(); }, {passive:false});

    syncAIBtn();
  }

  // --- game loop ---
  function step(t){
    if(lastTime===null) lastTime=t;
    const dt=t-lastTime; lastTime=t;

    if(aiEnabled) aiSteer();

    const interval = (!aiEnabled && downHeld) ? softDrop : baseDrop;

    // fix: no visual overshoot at floor
    if (collides(current, 0, 1)) {
      fallProgress = 0;
      dropTimer += dt;
      if (dropTimer >= interval) {
        dropTimer = 0;
        lock();
      }
    } else {
      dropTimer += dt;
      fallProgress += dt / interval;
      while (fallProgress >= 1) {
        fallProgress -= 1;
        if (!collides(current, 0, 1)) current.y++;
        else { fallProgress = 0; dropTimer = 0; lock(); break; }
      }
    }

    draw();
    requestAnimationFrame(step);
  }

  // start
  reset();
  bindMobileControls();
  resize();
  requestAnimationFrame(step);

  // po załadowaniu layoutu (mobile controls mogą zmieniać wysokość)
  setTimeout(resize, 0);
})();
</script>
</body>
</html>
